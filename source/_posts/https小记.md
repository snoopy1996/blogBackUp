---
title: https小记
date: 2018-08-15 15:51:21
tags: [技术, https]
---

最近看了几篇关于 HTTPS 的文章，讲的由浅入深，十分细致。所以这里也结合个人理解，做一个简单记录。

![](https://ws1.sinaimg.cn/large/0064OUUqly1fuafo0hm18j30ka06z44d.jpg)

`HTTPS`是 `HTTP Over SSL/TLS`。是基于`SSL/TLS`的`HTTP`，或者说是对`HTTP`做了一层封装。

<!--more-->

`HTTP` 即超文本传输协议，是用于 web 网络传输的基于`TCP`的传输层协议，主要用于客户端与服务端通信并传输数据，且所有`HTTP`的连接都是由客户端发起，服务端响应的。在`HTTP 1.0`时，所有的`HTTP`请求都是短连接，即当数据传输完成之后，立即关闭连接。而从 `HTTP 1.1` 开始，则默认使用长连接，即数据传输完成之后不会立即断开连接，而是继续保持——`keep-alive`，由客户端分析数据内容，然后再决定继续从服务端传输获取数据。

在`HTTP`中，数据传输过程是 `Data -> HTTP -> TCP -> IP -> Server`; 而 `HTTPS` 则是 `Data -> HTTP -> SSL/TLS -> TCP -> IP -> Server`。

`SSL`是“Secuer Sockets Layer”的缩写，是指“安全套阶层”，而`TLS`是“Transport Layer Security”——“传输层安全协议”，是标准化的`SSL`，所以，可以视两者为同一个东西在不同时期的不同叫法。

`HTTPS`的主要目的是：保证你连接的是你想连接的（个人理解）。

因为 HTTP 协议本身是明文传输，而且没有任何保护性安全性的措施，可以说所有基于`HTTP`的网站都是**不安全**的，因为所有通过`HTTP`的数据都可以被**劫持**甚至是**篡改**。

#### 如何提升一点安全性呢？

最简单的方法当然是 数据加密 传输。

比如 服务端和客户端约定某种**秘钥 S**，然后客户端与服务端的数据在传输之前都先用 S 加密，收到数据之后又用秘钥 S 解密，这样，就能保证在数据传输的过程中是加密状态，而且明文了，一下子就把安全系数提高了~

#### 真的是安全了么？

网站类应用很明显的一个特点是：Server 与 Client 是一对多的关系，而且这个比例还想当大，服务端只有一个，而客户端理论上是无限延展的。所以，如果所有的客户端都用同一个秘钥加密，显然是不合理的，只要破解了其中一个，那么就相当于破解了所有的客户端。

#### 客户端之间各自不同呢？

显然，需要每个客户端有自己的不同的秘钥，这样，我们才能基本保证安全一些。但是问题是，当客户端/服务端确定所使用的加密算法之后，如果通知对应的服务端/客户端呢？（协商对称加密算法过程）通过`HTTP`先传输过去么？可是，既然所有基于`HTTP`的数据都会被拦截篡改，那么又怎么保证实际接收到的算法是真正的算法呢？

如果有一个中间拦截机制，拦截到传输的**秘钥 A**，然后保存之后，再传输过去。那么，这个中间机制就可以破解所有的信息，因为他已经拿到了秘钥，只需要用手里的秘钥解密即可。

而对于各自的端而言，请求正常发送，正常响应，完全不知道自己的数据已经被劫持篡改了。

现在又该怎么办呢

#### 对秘钥加密？

之前说的，秘钥 S 加密，秘钥 S 解密的方式是对称加密，即加密秘钥即是解密秘钥，而在加密方式中，还有一种 **非对称加密**，比如`RSA`。

首先生成一个私钥，然后由私钥可以生成很多公钥。私钥加密的内容，所有公钥都可以破解，但公钥加密的内容，只有私钥可以解开。

当然，肯定不能直接把公钥发给客户端用来加密数据，因为只要拦截到一个公钥，那么所有的私钥加密内容都会被破解。但是我们可以利用这个特性来保证对称加密的秘钥正常达到两端。

如果我们将私钥保存在服务端，而给不同的客户端分发不同的公钥，那么只要客户端拿到了真正的公钥，其加密的内容即使被获取，也不会被破解，因为唯一的私钥保存在服务端，有且只有私钥可以解开加密内容。这时候，只需要在客户端**生成一个对称加密的私钥**，**用公钥加密之后再传回服务端**，然后这个客户端与服务端的所有通信都通过这个秘钥来进行加密，那么所有传输的数据可以说都是安全的。

#### 前提：客户端拿到的是真正的公钥

既然，中间机制可以拦截替换私钥，那么他当然也可以把公钥留下，然后自己制造一个假的公钥传输给客户端，然后就能通过不断的加密解密，一边获取信息一边维持正常的客户端服务端连接。所以，怎么才能保证客户端拿到真正的公钥，就是最后需要解决的问题。

这时候，就需要一种手段，能够让客户端自主验证拿到的公钥有没有被篡改。

#### 第三方加密解密

既然是让客户端自己验证公钥的完整性和真实性，所以验证过程肯定不能再和服务端有关联，否则就是一个 `while(true)`问题，想通过本次响应数据来确认上一次响应数据是否真实可靠就要保证本次响应数据的真实可靠。

所以，需要一个第三方机构，这个机构可以看做是一个公用非对称加密平台。服务端把公钥交给第三方机构的私钥去加密，然后再传给客户端，客户端收到之后，用本地的第三方机构公钥对数据进行解密，如果解密成功，则拿到服务端传输回来的公钥，反之，则数据被篡改。

可是，既然这个第三方平台是公用的，客户端能拿到公钥，中间机构也能拿到。同时，第三方平台可以给真实的服务端公钥进行加密，也能给中间机构的假公钥进行加密。如果被拦截替换了呢？客户端能解密，但是解密得到的公钥确是假的，客户端毫不知情。

#### 数字证书登场

所以，我们需要在加密的信息里做点文章，让数据本身带一个方法来验证数据的可靠性。

一般来说，开店要有营业证，毕业会有毕业证，生活中最常见的就是身份证，而所有的证件类物品有一个通用的属性——编号。除了证件本身可以被我们看到的信息以外，我们也可以拿着编号去证件颁发机构查询出证件信息，这时候，如果证件上的信息与查到的信息不一致，则很方便可以判断出这是一个伪冒证件。

所以，为什么不在传输数据里加个编号呢？如果客户端能够根据响应数据生成一个编号，同时又与传输的编号匹配，则数据是真实的。

同时，为了避免编号被篡改，所以编号也要进行一次加密，同样使用第三方机构的私钥进行加密。

这时候，就有了一个比较规范的数据传输约定：数字证书。

```
数字证书 = 网站信息 + 数字签名
# = 右边是示例
网站信息 = supersy.xyz + supersy的公钥 + 编号生成方法：MD5
# 加密后的编号
数字签名 = （网站信息 * MD5）* 第三方加密
```

那么，客户端拿到数字证书之后，自己使用编号生成方法对证书内容中的网站信息进行加密，然后通过本地第三方公钥对数字签名进行解密，把两者匹配对比，则可以验证数据的真实可靠性。

#### 一个小疑问：如果一整套都被替换呢？

如果整个数字证书被替换了，导致最后编号验证成功，又该怎么办？

比如，我们是 A 网站，请求的证书自然也是 A 网站的，可是，中间机构秘密替换成了 B 网站的证书。

其实，并不需要担心这种问题，如果一张身份证编号与身份证上的信息是对应的，那么只能说明这张身份证是真的，如果身份证是真的，那么只需要验证身份证的持有者是不是身份证本人即可，看一眼照片的事儿~

所以，回到这个场景里，我们只要在证书里加一个证书以外可以直接验证的简单直接的数据即可，就如同人的样貌。

在数据传输的场景中，我们的网站信息里包含了一个域名，即当前访问的域名地址，解密出的信息中必定是包含这样一个信息的，如果证书被替换，那么解密出的信息与当前环境必定是不匹配的，可以直接确定这个不是你想要的服务端的数据。

#### 能不能用一句话总结 HTTPS?

> HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。
